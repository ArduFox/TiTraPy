# coding: utf-8
#
# DataSources.py
# 
# part of TiTraPy
# contains my own DataSources for TableView
#
# 21. Juni 2019
#

import ui
import datetime
from datetime import timedelta
from datetime import date

import TiTra


 

# =============================== MyTaskDataSource ================================



class MyTaskDataSource(ui.ListDataSource):
	'''MyCalDataSource for TableView to Show Calender with Actions
		uses dict generated by TiTra.Calender.UIActionsOfDayList()
       
		with keys
		'title'
		'time'
		'minute'
		'task'
		'prj'
	'''
    
    
	def __init__(self, items, *args, **kwargs ):
		ui.ListDataSource.__init__(self, items, *args, **kwargs)
		self.itemlist=items
		self.total=0
		
		
	def tableview_number_of_sections(self, tableview):
		# Return the number of sections (defaults to 1)
		return 1
		
	def tableview_number_of_rows(self, tableview, section):
		# Return the number of rows in the section
		return len(tableview.data_source.items)
		
	def tableview_cell_for_row(self, tableview, section, row):
		# Create and return a cell for the given section/row
		
		# to get different cell types, pass subtitle or value1, or value2
		# to ui.TableViewCell() pass in as a string
		
		# TODO Brauche ich die cell aus der Mutterklasse als Basis?
		cell = ui.ListDataSource.tableview_cell_for_row(self,tableview,section,row)
		#
		if row % 2:
			cell.background_color=(0.94,0.96,1.0)
			
		v= cell.content_view
		
		label2 = ui.Label(name='l_task')
		label2.text = self.itemlist [row] ["task"]
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 15
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=180
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		if self.itemlist [row] ["id"] == 0 :
			label2.text_color=((0,0,0.8))
			label2.tint_color=((0,0,0.8))
		else :
			label2.text_color=(0)
			label2.tint_color=(0)
			
		v.add_subview(label2)

		
		label2 = ui.Label(name='l_prj')
		label2.text = str(self.itemlist [row] ["prj"])
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 200
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=150
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		if self.itemlist [row] ["id"] == 0 :
			label2.text_color=((0,0,0.8))
			label2.tint_color=((0,0,0.8))
		else :
			label2.text_color=(0)
			label2.tint_color=(0)
		v.add_subview(label2)		
				
		label2 = ui.Label(name='col')
		# label2.text = ""
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 350
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=tableview.row_height -3
		label2.font=("<system>",16)
		label2.bg_color=self.itemlist [row] ["color"]
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)		
		
		return cell
		
	def tableview_title_for_header(self, tableview, section):
		# Return a title for the given section.
		# If this is not implemented, no section headers will be shown.
		return f"list of tasks - select one and add it ..."
		
	def tableview_can_delete(self, tableview, section, row):
		# Return True if the user should be able to delete the given row.
		return True
		
	def tableview_can_move(self, tableview, section, row):
		# Return True if a reordering control should be shown for the given row (in editing mode).
		return False
		
# TableViewCell.content_view
# (readonly) The cell’s content view, which is resized automatically when the cell enters editing mode. 
# If you want to add custom views to the cell, it’s recommended that you add them to the content view,
# instead of the cell itself.
		
	def tableview_delete(self, tableview, section, row):
		# Called when the user confirms deletion of the given row.
		print(f"Task delete called! {section} {row}")	    	
		pass
		
	def tableview_move_row(self, tableview, from_section, from_row, to_section, to_row):
		# Called when the user moves a row with the reordering control (in editing mode).
		pass




# =============================== MyCalDataSource ================================



class MyCalDataSource(ui.ListDataSource):
	'''MyCalDataSource for TableView to Show Calender with Actions
		uses dict generated by TiTra.Calender.UIActionsOfDayList()
       
		with keys
		'title'
		'time'
		'minute'
		'task'
		'prj'
	'''
    
    
	def __init__(self,calender:TiTra.Calender, items, *args, **kwargs ):
		ui.ListDataSource.__init__(self, items, *args, **kwargs)
		self.itemlist=items
		self.total=0
		self.myCalender=calender
		
	def tableview_number_of_sections(self, tableview):
		# Return the number of sections (defaults to 1)
		return 1
		
	def tableview_number_of_rows(self, tableview, section):
		# Return the number of rows in the section
		return len(tableview.data_source.items)
		
	def tableview_cell_for_row(self, tableview, section, row):
		# Create and return a cell for the given section/row
		
		# to get different cell types, pass subtitle or value1, or value2
		# to ui.TableViewCell() pass in as a string
		
		# TODO Brauche ich die cell aus der Mutterklasse als Basis? Ja sonst habe ich gar keine Cell
		
		cell = ui.ListDataSource.tableview_cell_for_row(self,tableview,section,row)
		#
		if row % 2==0 : 
			cell.background_color=(1,1,0.90)
			
		v= cell.content_view
		
		
		label2 = ui.Label(name='l_time')
		label2.text = str(self.itemlist [row] ["time"])
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 15
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=50
		label2.font=("<system>",16)
#		label2.bg_color=(1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)
				
		label2 = ui.Label(name='l_task')
		label2.text = self.itemlist [row] ["task"]
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 65
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=135
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)

		
		label2 = ui.Label(name='l_prj')
		label2.text = str(self.itemlist [row] ["prj"])
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 200
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=150
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)
		
		label2 = ui.Label(name='col')
		# label2.text = ""
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 350
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=tableview.row_height -3
		label2.font=("<system>",16)
		label2.bg_color=self.itemlist [row] ["color"]
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)		
				
		return cell
		
	def tableview_title_for_header(self, tableview, section):
		# Return a title for the given section.
		# If this is not implemented, no section headers will be shown.
		return f"Action Entries of today - swipe delete works"
		
	def tableview_can_delete(self, tableview, section, row):
		# Return True if the user should be able to delete the given row.
		return True
		
	def tableview_can_move(self, tableview, section, row):
		# Return True if a reordering control should be shown for the given row (in editing mode).
		return False
		
# TableViewCell.content_view
# (readonly) The cell’s content view, which is resized automatically when the cell enters editing mode. 
# If you want to add custom views to the cell, it’s recommended that you add them to the content view,
# instead of the cell itself.
		
	def tableview_delete(self, tableview, section, row):
		# Called when the user confirms deletion of the given row.
		print(f"delete called! {section} {row}")	    	
		a=self.itemlist[row]
        
		#self.LogMessage(f"{a['date']} {a['time']} {a['title']}")        
		#print(a)
        
		time=datetime.datetime.strptime(f"{a['date']} {a['time']}", "%Y-%m-%d %H:%M")
        
		# self.LogMessage(time.strftime("%d.%m.%Y %H:%M:%S"))
		# print(f"\ntableview_delete: {a['date']} {a['time']} {a['titl']} ", time.strftime("%d.%m.%Y %H:%M:%S"))
        
		self.myCalender.removeIDAtTime(a['id'] , time)		
		ui.ListDataSource.tableview_delete(self,tableview,section,row)
		
		
	def tableview_move_row(self, tableview, from_section, from_row, to_section, to_row):
		# Called when the user moves a row with the reordering control (in editing mode).
		pass






# =============================== MyDurDataSource ================================






class MyDurDataSource(ui.ListDataSource):
	'''MyDurDataSource for TableView to Durations of Actions Actions
		uses dict based on that, generated by TiTra.Calender.CalcDurations()

       
		init has an aditionial parameter für the name of the main section
                     
		with keys
		'title' = Name of Task
		'hour'  = str of float format 0.0 Hours in this Task
		'prj' = Name of Project
	'''    
    
    
	def __init__(self, sect, items, *args, **kwargs ):
		ui.ListDataSource.__init__(self, items, *args, **kwargs)
		self.itemlist=items
		self.section_name=sect
		self.total=0
		for l in self.itemlist :
		    self.total+=float(l['hour'])
		self.total=round(self.total*10)/10
		
		
	def tableview_number_of_sections(self, tableview):
		# Return the number of sections (defaults to 1)
		return 1
		
	def tableview_number_of_rows(self, tableview, section):
		# Return the number of rows in the section
		return len(tableview.data_source.items)
		
	def tableview_cell_for_row(self, tableview, section, row):
		# Create and return a cell for the given section/row
		
		# to get different cell types, pass subtitle or value1, or value2
		# to ui.TableViewCell() pass in as a string
		cell = ui.ListDataSource.tableview_cell_for_row(self,tableview,section,row)
		#
		if row % 2:
			cell.background_color=(0.94,0.96,1.0)

		v= cell.content_view
		label2 = ui.Label(name='l_prj')
		label2.text = self.itemlist [row] ["prj"]
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 200
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=250
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)

		label2 = ui.Label(name='l_hour')
		label2.text = f"{self.itemlist [row] ['hour']} h"
		label2.alignment=ui.ALIGN_RIGHT
		label2.x = 300
		label2.y = 2
		label2.height=tableview.row_height -4
		label2.width=50
		label2.font=("<system>",16)
#		label2.bg_color=(0.95, 1.0 ,1.0,1.0)
		if float(self.itemlist [row] ['hour'])> self.total *.15 :
			label2.text_color=(0.7, 0, 0)
			label2.tint_color=(0.7, 0, 0)      
		else :      
			label2.text_color=(0)
			label2.tint_color=(0)
		v.add_subview(label2)

		
		return cell
		
	def tableview_title_for_header(self, tableview, section):
		# Return a title for the given section.
		# If this is not implemented, no section headers will be shown.
		return f"{self.section_name} report in hours, total = {self.total} h"
		
	def tableview_can_delete(self, tableview, section, row):
		# Return True if the user should be able to delete the given row.
		return False
		
	def tableview_can_move(self, tableview, section, row):
		# Return True if a reordering control should be shown for the given row (in editing mode).
		return False
		
# TableViewCell.content_view
# (readonly) The cell’s content view, which is resized automatically when the cell enters editing mode. 
# If you want to add custom views to the cell, it’s recommended that you add them to the content view,
# instead of the cell itself.
		
	def tableview_delete(self, tableview, section, row):
		# Called when the user confirms deletion of the given row.
		# print(f"delete called! {section} {row}")	    	
		pass
		
	def tableview_move_row(self, tableview, from_section, from_row, to_section, to_row):
		# Called when the user moves a row with the reordering control (in editing mode).
		pass
    	        	    

