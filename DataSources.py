# coding: utf-8
#
# DataSources.py
# 
# part of TiTraPy
# contains my own DataSources for TableView
#
# 22. August 2019
#
#
# -----------------------------------------------------------------------------
#    Licence & Copyright
# -----------------------------------------------------------------------------
#
#    Copyright 2019 ArduFox (Wolfgang Fuchs)
#
#    This file is part of TiTraPy.
#
#    TiTraPy is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    TiTraPy is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with TiTraPy.  If not, see <http://www.gnu.org/licenses/>.
#


import ui
import datetime
from datetime import timedelta
from datetime import date

import TiTra


 

# =============================== MyTaskDataSource ============================



class MyTaskDataSource(ui.ListDataSource):
	'''MyCalDataSource for TableView to Show Calender with Actions
		uses dict generated by TiTra.Calender.UIActionsOfDayList()
       
		with keys
		'title'
		'time'
		'minute'
		'task'
		'prj'
	'''
    
    
	def __init__(self, items, *args, **kwargs ):
		ui.ListDataSource.__init__(self, items, *args, **kwargs)
		self.itemlist=items
		self.total=0
		
		
	def tableview_number_of_sections(self, tableview):
		# Return the number of sections (defaults to 1)
		return 1
		
	def tableview_number_of_rows(self, tableview, section):
		# Return the number of rows in the section
		return len(tableview.data_source.items)
		
	def tableview_cell_for_row(self, tableview, section, row):
		# Create and return a cell for the given section/row
		
		# to get different cell types, pass subtitle or value1, or value2
		# to ui.TableViewCell() pass in as a string
		
		# TODO Brauche ich die cell aus der Mutterklasse als Basis?
		cell = ui.ListDataSource.tableview_cell_for_row(self,tableview,section,row)
		#
		if row % 2:
			cell.background_color=(0.94,0.96,1.0)
			
		v= cell.content_view
		
		label2 = ui.Label(name='l_task')
		label2.text = self.itemlist [row] ["task"]
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 15
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=180
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		if self.itemlist [row] ["id"] == 0 :
			label2.text_color=((0,0,0.8))
			label2.tint_color=((0,0,0.8))
		else :
			label2.text_color=(0)
			label2.tint_color=(0)
			
		v.add_subview(label2)

		
		label2 = ui.Label(name='l_prj')
		label2.text = str(self.itemlist [row] ["prj"])
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 200
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=150
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		if self.itemlist [row] ["id"] == 0 :
			label2.text_color=((0,0,0.8))
			label2.tint_color=((0,0,0.8))
		else :
			label2.text_color=(0)
			label2.tint_color=(0)
		v.add_subview(label2)		
				
		label2 = ui.Label(name='col')
		# label2.text = ""
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 350
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=tableview.row_height -3
		label2.font=("<system>",16)
		label2.bg_color=self.itemlist [row] ["color"]
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)		
		
		return cell
		
	def tableview_title_for_header(self, tableview, section):
		# Return a title for the given section.
		# If this is not implemented, no section headers will be shown.
		return f"list of tasks - select one and add it ..."
		
	def tableview_can_delete(self, tableview, section, row):
		# Return True if the user should be able to delete the given row.
		return True
		
	def tableview_can_move(self, tableview, section, row):
		# Return True if a reordering control should be shown for the given row (in editing mode).
		return False
		
# TableViewCell.content_view
# (readonly) The cell’s content view, which is resized automatically when the cell enters editing mode. 
# If you want to add custom views to the cell, it’s recommended that you add them to the content view,
# instead of the cell itself.
		
	def tableview_delete(self, tableview, section, row):
		# Called when the user confirms deletion of the given row.
#		print(f"Task delete called! {section} {row}")	    	
		pass
		
	def tableview_move_row(self, tableview, from_section, from_row, to_section, to_row):
		# Called when the user moves a row with the reordering control (in editing mode).
		pass




# =============================== MyCalDataSource ================================



class MyCalDataSource(ui.ListDataSource):
	'''MyCalDataSource for TableView to Show Calender with Actions
		uses dict generated by TiTra.Calender.UIActionsOfDayList()
       
		with keys
		'title'
		'time'
		'minute'
		'task'
		'prj'
	'''
    
    
	def __init__(self,calender:TiTra.Calender, items, *args, **kwargs ):
		ui.ListDataSource.__init__(self, items, *args, **kwargs)
		self.itemlist=items
		self.total=0
		self.myCalender=calender
		
		
	def tableview_number_of_sections(self, tableview):
		# Return the number of sections (defaults to 1)
		return 1
		
	def tableview_number_of_rows(self, tableview, section):
		# Return the number of rows in the section
		return len(tableview.data_source.items)
		
	def tableview_cell_for_row(self, tableview, section, row):
		# Create and return a cell for the given section/row
		
		# to get different cell types, pass subtitle or value1, or value2
		# to ui.TableViewCell() pass in as a string
		
		# TODO Brauche ich die cell aus der Mutterklasse als Basis? Ja sonst habe ich gar keine Cell
		
		cell = ui.ListDataSource.tableview_cell_for_row(self,tableview,section,row)
		#
		if row % 2==0 : 
			cell.background_color=(1,1,0.90)
			
		v= cell.content_view
		
		
		label2 = ui.Label(name='l_time')
		label2.text = str(self.itemlist [row] ["time"])
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 15
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=50
		label2.font=("<system>",16)
#		label2.bg_color=(1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)
				
		label2 = ui.Label(name='l_task')
		label2.text = self.itemlist [row] ["task"]
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 65
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=135
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)

		
		label2 = ui.Label(name='l_prj')
		label2.text = str(self.itemlist [row] ["prj"])
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 200
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=150
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)
		
		label2 = ui.Label(name='col')
		# label2.text = ""
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 350
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=tableview.row_height -3
		label2.font=("<system>",16)
		label2.bg_color=self.itemlist [row] ["color"]
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)		
				
		return cell
		
	def tableview_title_for_header(self, tableview, section):
		# Return a title for the given section.
		# If this is not implemented, no section headers will be shown.
		return f"Action Entries of today - swipe delete works"
		
	def tableview_can_delete(self, tableview, section, row):
		# Return True if the user should be able to delete the given row.
		return True
		
	def tableview_can_move(self, tableview, section, row):
		# Return True if a reordering control should be shown for the given row (in editing mode).
		return False
		
# TableViewCell.content_view
# (readonly) The cell’s content view, which is resized automatically when the cell enters editing mode. 
# If you want to add custom views to the cell, it’s recommended that you add them to the content view,
# instead of the cell itself.
		
	def tableview_delete(self, tableview, section, row):
		# Called when the user confirms deletion of the given row.
#		print(f"delete called! {section} {row}")	    	
		a=self.itemlist[row]
                
		time=datetime.datetime.strptime(f"{a['date']} {a['time']}", "%Y-%m-%d %H:%M")
		# self.LogMessage(time.strftime("%d.%m.%Y %H:%M:%S"))
		# print(f"\ntableview_delete: {a['date']} {a['time']} {a['titl']} ", time.strftime("%d.%m.%Y %H:%M:%S"))
		
		self.myCalender.removeIDAtTime(a['id'] , time)		
		ui.ListDataSource.tableview_delete(self,tableview,section,row)
		
		tableview.superview.UpdateBoxChart()
		
	def tableview_move_row(self, tableview, from_section, from_row, to_section, to_row):
		# Called when the user moves a row with the reordering control (in editing mode).
		pass






# =============================== MyDurDataSource ================================






class MyDurDataSource(ui.ListDataSource):
	'''MyDurDataSource for TableView to Durations of Actions Actions
		uses dict based on that, generated by TiTra.Calender.CalcDurations()

       
		init has an aditionial parameter für the name of the main section
                     
		with keys
		'title' = Name of Task
		'hour'  = str of float format 0.0 Hours in this Task
		'prj' = Name of Project
	'''    
    
    
	def __init__(self, sect, items, *args, **kwargs ):
		ui.ListDataSource.__init__(self, items, *args, **kwargs)
		self.itemlist=items
		self.section_name=sect
		self.total=0
		for l in self.itemlist :
		    self.total+=float(l['hour'])
		self.total=round(self.total*10)/10
		
		
	def tableview_number_of_sections(self, tableview):
		# Return the number of sections (defaults to 1)
		return 1
		
	def tableview_number_of_rows(self, tableview, section):
		# Return the number of rows in the section
		return len(tableview.data_source.items)
		
	def tableview_cell_for_row(self, tableview, section, row):
		# Create and return a cell for the given section/row
		
		# to get different cell types, pass subtitle or value1, or value2
		# to ui.TableViewCell() pass in as a string
		cell = ui.ListDataSource.tableview_cell_for_row(self,tableview,section,row)
		#
		if row % 2:
			cell.background_color=(0.94,0.96,1.0)

		v= cell.content_view
		label2 = ui.Label(name='l_prj')
		label2.text = self.itemlist [row] ["prj"]
		label2.alignment=ui.ALIGN_LEFT
		label2.x = 200
		label2.y = 1
		label2.height=tableview.row_height -3
		label2.width=250
		label2.font=("<system>",16)
#		label2.bg_color=(0.90, 0.95 ,1.0,1.0)
		label2.text_color=(0)
		label2.tint_color=(0)
		v.add_subview(label2)

		label2 = ui.Label(name='l_hour')
		label2.text = f"{self.itemlist [row] ['hour']} h"
		label2.alignment=ui.ALIGN_RIGHT
		label2.x = 300
		label2.y = 2
		label2.height=tableview.row_height -4
		label2.width=50
		label2.font=("<system>",16)
#		label2.bg_color=(0.95, 1.0 ,1.0,1.0)
		if float(self.itemlist [row] ['hour'])> self.total *.15 :
			label2.text_color=(0.7, 0, 0)
			label2.tint_color=(0.7, 0, 0)      
		else :      
			label2.text_color=(0)
			label2.tint_color=(0)
		v.add_subview(label2)

		
		return cell
		
	def tableview_title_for_header(self, tableview, section):
		# Return a title for the given section.
		# If this is not implemented, no section headers will be shown.
		return f"{self.section_name} report in hours, total = {self.total} h"
		
	def tableview_can_delete(self, tableview, section, row):
		# Return True if the user should be able to delete the given row.
		return False
		
	def tableview_can_move(self, tableview, section, row):
		# Return True if a reordering control should be shown for the given row (in editing mode).
		return False
		
# TableViewCell.content_view
# (readonly) The cell’s content view, which is resized automatically when the cell enters editing mode. 
# If you want to add custom views to the cell, it’s recommended that you add them to the content view,
# instead of the cell itself.
		
	def tableview_delete(self, tableview, section, row):
		# Called when the user confirms deletion of the given row.
		# print(f"delete called! {section} {row}")	    	
		pass
		
	def tableview_move_row(self, tableview, from_section, from_row, to_section, to_row):
		# Called when the user moves a row with the reordering control (in editing mode).
		pass
    	        	    

